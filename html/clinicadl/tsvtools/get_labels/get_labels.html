<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>clinicadl.tsvtools.get_labels.get_labels API documentation</title>
<meta name="description" content="Source files can be obtained by running the following commands on a BIDS folder:
- clinica iotools merge-tsv
- clinica iotools …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clinicadl.tsvtools.get_labels.get_labels</code></h1>
</header>
<section id="section-intro">
<p>Source files can be obtained by running the following commands on a BIDS folder:
- clinica iotools merge-tsv
- clinica iotools check-missing-modalities
To download Clinica follow the instructions at <a href="http://www.clinica.run/doc/#installation">http://www.clinica.run/doc/#installation</a></p>
<p>NB: Other preprocessing may be needed on the merged file obtained: for example the selection of subjects older than 62
in the OASIS dataset is not done in this script. Moreover a quality check may be needed at the end of preprocessing
pipelines, leading to the removal of some subjects.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding: utf8

&#34;&#34;&#34;
Source files can be obtained by running the following commands on a BIDS folder:
 - clinica iotools merge-tsv
 - clinica iotools check-missing-modalities
To download Clinica follow the instructions at http://www.clinica.run/doc/#installation

NB: Other preprocessing may be needed on the merged file obtained: for example the selection of subjects older than 62
in the OASIS dataset is not done in this script. Moreover a quality check may be needed at the end of preprocessing
pipelines, leading to the removal of some subjects.
&#34;&#34;&#34;
import os
from copy import copy
from logging import getLogger
from os import path
from typing import Dict, List

import numpy as np
import pandas as pd

from clinicadl.utils.exceptions import ClinicaDLArgumentError, ClinicaDLTSVError
from clinicadl.utils.maps_manager.iotools import commandline_to_json
from clinicadl.utils.tsvtools_utils import (
    after_end_screening,
    cleaning_nan_diagnoses,
    find_label,
    first_session,
    last_session,
    merged_tsv_reader,
    neighbour_session,
)

logger = getLogger(&#34;clinicadl&#34;)


def infer_or_drop_diagnosis(bids_df: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Deduce the diagnosis when missing from previous and following sessions of the subject. If not identical, the session
    is dropped. Sessions with no diagnosis are also dropped when there are the last sessions of the follow-up.

    Parameters
    ----------
    bids_df: DataFrame
        Columns including [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;]

    Returns
    -------
    bids_copy_df: DataFrame
        Cleaned copy of the input bids_df
    &#34;&#34;&#34;
    bids_copy_df = copy(bids_df)
    found_diag_interpol = 0
    nb_drop = 0

    for subject, subject_df in bids_df.groupby(level=0):
        session_list = []
        for _, session in subject_df.index.values:
            x = session[5::]
            if not x.isdigit():
                subject_df.drop((subject, session), axis=0, inplace=True)
                bids_copy_df.drop((subject, session), axis=0, inplace=True)
                nb_drop += 1

        session_list = [session for _, session in subject_df.index.values]

        for _, session in subject_df.index.values:
            diagnosis = subject_df.loc[(subject, session), &#34;diagnosis&#34;]
            session_nb = session

            if isinstance(diagnosis, float):
                if session == last_session(session_list):
                    bids_copy_df.drop(index=(_, session), axis=0, inplace=True)
                    nb_drop += 1
                else:
                    prev_session = neighbour_session(session_nb, session_list, -1)
                    prev_diagnosis = bids_df.loc[(subject, prev_session), &#34;diagnosis&#34;]
                    while isinstance(
                        prev_diagnosis, float
                    ) and prev_session != first_session(subject_df):
                        prev_session = neighbour_session(prev_session, session_list, -1)
                        prev_diagnosis = bids_df.loc[
                            (subject, prev_session), &#34;diagnosis&#34;
                        ]
                    post_session = neighbour_session(session_nb, session_list, +1)
                    post_diagnosis = bids_df.loc[(subject, post_session), &#34;diagnosis&#34;]
                    while isinstance(
                        post_diagnosis, float
                    ) and post_session != last_session(session_list):
                        post_session = neighbour_session(post_session, session_list, +1)
                        post_diagnosis = bids_df.loc[
                            (subject, post_session), &#34;diagnosis&#34;
                        ]
                    if prev_diagnosis == post_diagnosis:
                        found_diag_interpol += 1
                        bids_copy_df.loc[
                            (subject, session), &#34;diagnosis&#34;
                        ] = prev_diagnosis
                    else:
                        bids_copy_df.drop((subject, session), inplace=True)
                        nb_drop += 1

    logger.info(f&#34;Inferred diagnosis: {found_diag_interpol}&#34;)
    logger.info(f&#34;Dropped subjects (inferred diagnosis): {nb_drop}&#34;)

    return bids_copy_df


def mod_selection(
    bids_df: pd.DataFrame, missing_mods_dict: Dict[str, pd.DataFrame], mod: str = &#34;t1w&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Select only sessions for which the modality is present

    Parameters
    ----------
    bids_df: DataFrame
        Columns include [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;]
    missing_mods_dict: dictionary of str and DataFrame
        DataFrames of missing modalities
    mod: str
        the modality used for selection

    Returns
    -------
    copy_bids_df: DataFrame
        Cleaned copy of the input bids_df
    &#34;&#34;&#34;
    bids_copy_df = copy(bids_df)
    nb_subjects = 0
    if mod is not None:
        for subject, session in bids_df.index.values:
            session_mod = session[:5] + session[6:8]
            try:
                mod_present = missing_mods_dict[session_mod].loc[subject, mod]
                if not mod_present:
                    bids_copy_df.drop((subject, session), inplace=True)
                    nb_subjects += 1
            except KeyError:
                bids_copy_df.drop((subject, session), inplace=True)
                nb_subjects += 1
    logger.info(f&#34;Dropped subjects (mod selection): {nb_subjects}&#34;)
    return bids_copy_df


def remove_unique_session(bids_df: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    A method to get the subgroup for each sessions depending on their stability on the time horizon

    Parameters
    ----------
    bids_df: DataFrame
        Columns include [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;]

    Returns
    -------
    bids_copy_df: DataFrame
        Cleaned copy of the input bids_df
    &#34;&#34;&#34;
    bids_copy_df = copy(bids_df)
    nb_unique = 0

    for subject, subject_df in bids_df.groupby(level=0):

        session_list = [session for _, session in subject_df.index.values]
        session_list.sort()
        nb_session = len(session_list)
        if nb_session == 1:
            bids_copy_df.drop((subject, session_list[0]), inplace=True)
            subject_df.drop((subject, session_list[0]), inplace=True)
            nb_unique += 1
    logger.info(f&#34;Dropped subjects (unique session): {nb_unique}&#34;)

    return bids_copy_df


def diagnosis_removal(bids_df: pd.DataFrame, diagnosis_list: List[str]) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Removes sessions for which the diagnosis is not in the list provided

    Parameters
    ----------
    bids_df: DataFrame
        Columns must includes [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;]
    diagnosis_list: list of str
        List of diagnoses that will be removed

    Returns
    -------
    output_df: DataFrame
        Cleaned copy of the input bids_df

    &#34;&#34;&#34;

    output_df = copy(bids_df)
    nb_subjects = 0
    for subject, subject_df in bids_df.groupby(level=0):
        for (_, session) in subject_df.index.values:
            group = subject_df.loc[(subject, session), &#34;diagnosis&#34;]
            if group not in diagnosis_list:
                output_df.drop((subject, session), inplace=True)
                nb_subjects += 1

    logger.info(f&#34;Dropped subjects (diagnoses): {nb_subjects}&#34;)
    return output_df


def apply_restriction(bids_df: pd.DataFrame, restriction_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Application of a restriction (for example after the removal of some subjects after a preprocessing pipeline)

    Parameters
    ----------
    bids_df: DataFrame
        Columns must include [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;]
    restriction_path: str (path)
        Path to a tsv file with columns including [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;] including
        all the sessions that can be included

    Returns
    -------
    bids_copy_df: DataFrame
        Cleaned copy of the input bids_df
    &#34;&#34;&#34;
    bids_copy_df = copy(bids_df)
    nb_subjects = 0
    if restriction_path is not None:
        restriction_df = pd.read_csv(restriction_path, sep=&#34;\t&#34;)

        for subject, session in bids_df.index.values:
            subject_qc_df = restriction_df[
                (restriction_df.participant_id == subject)
                &amp; (restriction_df.session_id == session)
            ]
            if len(subject_qc_df) != 1:
                bids_copy_df.drop((subject, session), inplace=True)
                nb_subjects += 1
    logger.info(f&#34;Dropped subjects (apply restriction): {nb_subjects}&#34;)
    return bids_copy_df


def get_labels(
    bids_directory: str,
    diagnoses: List[str],
    modality: str = &#34;t1w&#34;,
    restriction_path: str = None,
    variables_of_interest: List[str] = None,
    remove_smc: bool = True,
    caps_directory: str = None,
    merged_tsv: str = None,
    missing_mods: str = None,
    remove_unique_session: bool = False,
):
    &#34;&#34;&#34;
    Writes one TSV file based on merged_tsv and missing_mods.


    Parameters
    ----------
    bids_directory: str (path)
        Path to the folder containing the dataset in a BIDS hierarchy.
    diagnoses: List of str
        Labels that must be extracted from merged_tsv.
    modality: str
        Modality to select sessions. Sessions which do not include the modality will be excluded.
    restriction_path: str (path)
        Path to a tsv containing the sessions that can be included.
    variables_of_interest: List of str
        Columns that should be kept in the output tsv files.
    remove_smc: bool
        If True SMC participants are removed from the lists.
    caps_directory: str (path)
        Path to a folder of a older of a CAPS compliant dataset
    merged_tsv: str (path)
        Path to the output of clinica iotools merge-tsv if already exists
    missing_mods: str (path)
        Path to the output directory of clinica iotools check-missing-modalities if already exists
    remove_unique_session: bool
        If True, subjects with only one session are removed.
    &#34;&#34;&#34;

    from pathlib import Path

    results_directory = Path(bids_directory).parents[0]
    output_tsv = results_directory / &#34;labels.tsv&#34;

    commandline_to_json(
        {
            &#34;bids_directory&#34;: bids_directory,
            &#34;output_dir&#34;: results_directory,
            &#34;diagnoses&#34;: diagnoses,
            &#34;modality&#34;: modality,
            &#34;restriction_path&#34;: restriction_path,
            &#34;variables_of_interest&#34;: variables_of_interest,
            &#34;remove_smc&#34;: remove_smc,
            &#34;caps&#34;: caps_directory,
            &#34;missing_mods&#34;: missing_mods,
            &#34;merged_tsv&#34;: merged_tsv,
            &#34;remove_unique_session&#34;: remove_unique_session,
        },
        filename=&#34;labels.json&#34;,
    )

    import os

    from clinica.iotools.utils.data_handling import (
        compute_missing_mods,
        create_merge_file,
    )
    from clinica.utils.inputs import check_bids_folder

    # Create the results directory
    os.makedirs(results_directory, exist_ok=True)

    # Generating the output of `clinica iotools check-missing-modalities``
    missing_mods_directory = os.path.join(results_directory, &#34;missing_mods&#34;)
    if missing_mods is not None:
        missing_mods_directory = missing_mods

    if not os.path.exists(missing_mods_directory):
        check_bids_folder(bids_directory)
        compute_missing_mods(bids_directory, missing_mods_directory, &#34;missing_mods&#34;)

    logger.info(
        f&#34;output of clinica iotools check-missing-modalities: {missing_mods_directory}&#34;
    )

    # Generating the output of `clinica iotools merge-tsv `
    merged_tsv_path = os.path.join(results_directory, &#34;merge.tsv&#34;)
    if merged_tsv is not None:
        merged_tsv_path = merged_tsv
    elif not os.path.exists(merged_tsv_path):
        logger.info(&#34;create merge tsv&#34;)
        check_bids_folder(bids_directory)
        create_merge_file(
            bids_directory,
            os.path.join(results_directory, &#34;merge.tsv&#34;),
            caps_dir=caps_directory,
            pipelines=None,
            ignore_scan_files=None,
            ignore_sessions_files=None,
            volume_atlas_selection=None,
            freesurfer_atlas_selection=None,
            pvc_restriction=None,
            tsv_file=None,
            group_selection=False,
            tracers_selection=False,
        )

    logger.info(f&#34;output of clinica iotools merge-tsv: {merged_tsv_path}&#34;)

    # Reading files
    bids_df = merged_tsv_reader(merged_tsv_path)
    bids_df.set_index([&#34;participant_id&#34;, &#34;session_id&#34;], inplace=True)
    variables_list = []

    if &#34;dx1&#34; in bids_df.columns:
        bids_df.rename(columns={&#34;dx1&#34;: &#34;diagnosis&#34;}, inplace=True)

    try:
        variables_list.append(find_label(bids_df.columns.values, &#34;age&#34;))
        variables_list.append(find_label(bids_df.columns.values, &#34;sex&#34;))
        variables_list.append(find_label(bids_df.columns.values, &#34;diagnosis&#34;))
    except ValueError:
        logger.warning(
            &#34;The age, sex or diagnosis values were not found in the dataset.&#34;
        )

    # Cleaning NaN diagnosis
    bids_df = cleaning_nan_diagnoses(bids_df)

    # Checking the variables of interest
    if variables_of_interest is not None:
        variables_set = set(variables_of_interest) | set(variables_list)
        variables_list = list(variables_set)
        if not set(variables_list).issubset(set(bids_df.columns.values)):
            raise ClinicaDLArgumentError(
                f&#34;The variables asked by the user {variables_of_interest} do not &#34;
                f&#34;exist in the data set.&#34;
            )

    # Loading missing modalities files
    list_files = os.listdir(missing_mods_directory)
    missing_mods_dict = {}

    for file in list_files:
        filename, fileext = path.splitext(file)
        if fileext == &#34;.tsv&#34;:
            session = filename.split(&#34;_&#34;)[-1]
            missing_mods_df = pd.read_csv(
                path.join(missing_mods_directory, file), sep=&#34;\t&#34;
            )
            if len(missing_mods_df) == 0:
                raise ClinicaDLTSVError(
                    f&#34;Given TSV file at {path.join(missing_mods_directory, file)} loads an empty DataFrame.&#34;
                )

            missing_mods_df.set_index(&#34;participant_id&#34;, drop=True, inplace=True)
            missing_mods_dict[session] = missing_mods_df

    # Remove SMC patients
    if remove_smc:
        if &#34;diagnosis_bl&#34; in bids_df.columns.values:  # Retro-compatibility
            bids_df = bids_df[~(bids_df.diagnosis_bl == &#34;SMC&#34;)]
        if &#34;diagnosis_sc&#34; in bids_df.columns.values:
            bids_df = bids_df[~(bids_df.diagnosis_sc == &#34;SMC&#34;)]

    # Adding the field baseline_diagnosis
    bids_copy_df = copy(bids_df)
    bids_copy_df[&#34;baseline_diagnosis&#34;] = pd.Series(
        np.zeros(len(bids_df)), index=bids_df.index
    )
    for subject, subject_df in bids_df.groupby(level=0):
        baseline_diagnosis = subject_df.loc[
            (subject, first_session(subject_df)), &#34;diagnosis&#34;
        ]
        bids_copy_df.loc[subject, &#34;baseline_diagnosis&#34;] = baseline_diagnosis

    bids_df = copy(bids_copy_df)
    variables_list.append(&#34;baseline_diagnosis&#34;)

    bids_df = bids_df[variables_list]
    if remove_unique_session:
        bids_df = remove_unique_session(bids_df)

    variables_list.remove(&#34;baseline_diagnosis&#34;)
    output_df = bids_df[variables_list]
    output_df = infer_or_drop_diagnosis(output_df)
    output_df = diagnosis_removal(output_df, diagnoses)
    output_df = mod_selection(output_df, missing_mods_dict, modality)
    output_df = apply_restriction(output_df, restriction_path)

    output_df.reset_index()
    output_df.sort_values(by=[&#34;participant_id&#34;, &#34;session_id&#34;], inplace=True)
    output_df.to_csv(output_tsv, sep=&#34;\t&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="clinicadl.tsvtools.get_labels.get_labels.apply_restriction"><code class="name flex">
<span>def <span class="ident">apply_restriction</span></span>(<span>bids_df: pandas.core.frame.DataFrame, restriction_path: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Application of a restriction (for example after the removal of some subjects after a preprocessing pipeline)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bids_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Columns must include ['participant_id', 'session_id', 'diagnosis']</dd>
<dt><strong><code>restriction_path</code></strong> :&ensp;<code>str (path)</code></dt>
<dd>Path to a tsv file with columns including ['participant_id', 'session_id', 'diagnosis'] including
all the sessions that can be included</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bids_copy_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Cleaned copy of the input bids_df</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_restriction(bids_df: pd.DataFrame, restriction_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Application of a restriction (for example after the removal of some subjects after a preprocessing pipeline)

    Parameters
    ----------
    bids_df: DataFrame
        Columns must include [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;]
    restriction_path: str (path)
        Path to a tsv file with columns including [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;] including
        all the sessions that can be included

    Returns
    -------
    bids_copy_df: DataFrame
        Cleaned copy of the input bids_df
    &#34;&#34;&#34;
    bids_copy_df = copy(bids_df)
    nb_subjects = 0
    if restriction_path is not None:
        restriction_df = pd.read_csv(restriction_path, sep=&#34;\t&#34;)

        for subject, session in bids_df.index.values:
            subject_qc_df = restriction_df[
                (restriction_df.participant_id == subject)
                &amp; (restriction_df.session_id == session)
            ]
            if len(subject_qc_df) != 1:
                bids_copy_df.drop((subject, session), inplace=True)
                nb_subjects += 1
    logger.info(f&#34;Dropped subjects (apply restriction): {nb_subjects}&#34;)
    return bids_copy_df</code></pre>
</details>
</dd>
<dt id="clinicadl.tsvtools.get_labels.get_labels.diagnosis_removal"><code class="name flex">
<span>def <span class="ident">diagnosis_removal</span></span>(<span>bids_df: pandas.core.frame.DataFrame, diagnosis_list: List[str]) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Removes sessions for which the diagnosis is not in the list provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bids_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Columns must includes ['participant_id', 'session_id', 'diagnosis']</dd>
<dt><strong><code>diagnosis_list</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of diagnoses that will be removed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Cleaned copy of the input bids_df</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagnosis_removal(bids_df: pd.DataFrame, diagnosis_list: List[str]) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Removes sessions for which the diagnosis is not in the list provided

    Parameters
    ----------
    bids_df: DataFrame
        Columns must includes [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;]
    diagnosis_list: list of str
        List of diagnoses that will be removed

    Returns
    -------
    output_df: DataFrame
        Cleaned copy of the input bids_df

    &#34;&#34;&#34;

    output_df = copy(bids_df)
    nb_subjects = 0
    for subject, subject_df in bids_df.groupby(level=0):
        for (_, session) in subject_df.index.values:
            group = subject_df.loc[(subject, session), &#34;diagnosis&#34;]
            if group not in diagnosis_list:
                output_df.drop((subject, session), inplace=True)
                nb_subjects += 1

    logger.info(f&#34;Dropped subjects (diagnoses): {nb_subjects}&#34;)
    return output_df</code></pre>
</details>
</dd>
<dt id="clinicadl.tsvtools.get_labels.get_labels.get_labels"><code class="name flex">
<span>def <span class="ident">get_labels</span></span>(<span>bids_directory: str, diagnoses: List[str], modality: str = 't1w', restriction_path: str = None, variables_of_interest: List[str] = None, remove_smc: bool = True, caps_directory: str = None, merged_tsv: str = None, missing_mods: str = None, remove_unique_session: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes one TSV file based on merged_tsv and missing_mods.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bids_directory</code></strong> :&ensp;<code>str (path)</code></dt>
<dd>Path to the folder containing the dataset in a BIDS hierarchy.</dd>
<dt><strong><code>diagnoses</code></strong> :&ensp;<code>List</code> of <code>str</code></dt>
<dd>Labels that must be extracted from merged_tsv.</dd>
<dt><strong><code>modality</code></strong> :&ensp;<code>str</code></dt>
<dd>Modality to select sessions. Sessions which do not include the modality will be excluded.</dd>
<dt><strong><code>restriction_path</code></strong> :&ensp;<code>str (path)</code></dt>
<dd>Path to a tsv containing the sessions that can be included.</dd>
<dt><strong><code>variables_of_interest</code></strong> :&ensp;<code>List</code> of <code>str</code></dt>
<dd>Columns that should be kept in the output tsv files.</dd>
<dt><strong><code>remove_smc</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True SMC participants are removed from the lists.</dd>
<dt><strong><code>caps_directory</code></strong> :&ensp;<code>str (path)</code></dt>
<dd>Path to a folder of a older of a CAPS compliant dataset</dd>
<dt><strong><code>merged_tsv</code></strong> :&ensp;<code>str (path)</code></dt>
<dd>Path to the output of clinica iotools merge-tsv if already exists</dd>
<dt><strong><code>missing_mods</code></strong> :&ensp;<code>str (path)</code></dt>
<dd>Path to the output directory of clinica iotools check-missing-modalities if already exists</dd>
<dt><strong><code>remove_unique_session</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, subjects with only one session are removed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_labels(
    bids_directory: str,
    diagnoses: List[str],
    modality: str = &#34;t1w&#34;,
    restriction_path: str = None,
    variables_of_interest: List[str] = None,
    remove_smc: bool = True,
    caps_directory: str = None,
    merged_tsv: str = None,
    missing_mods: str = None,
    remove_unique_session: bool = False,
):
    &#34;&#34;&#34;
    Writes one TSV file based on merged_tsv and missing_mods.


    Parameters
    ----------
    bids_directory: str (path)
        Path to the folder containing the dataset in a BIDS hierarchy.
    diagnoses: List of str
        Labels that must be extracted from merged_tsv.
    modality: str
        Modality to select sessions. Sessions which do not include the modality will be excluded.
    restriction_path: str (path)
        Path to a tsv containing the sessions that can be included.
    variables_of_interest: List of str
        Columns that should be kept in the output tsv files.
    remove_smc: bool
        If True SMC participants are removed from the lists.
    caps_directory: str (path)
        Path to a folder of a older of a CAPS compliant dataset
    merged_tsv: str (path)
        Path to the output of clinica iotools merge-tsv if already exists
    missing_mods: str (path)
        Path to the output directory of clinica iotools check-missing-modalities if already exists
    remove_unique_session: bool
        If True, subjects with only one session are removed.
    &#34;&#34;&#34;

    from pathlib import Path

    results_directory = Path(bids_directory).parents[0]
    output_tsv = results_directory / &#34;labels.tsv&#34;

    commandline_to_json(
        {
            &#34;bids_directory&#34;: bids_directory,
            &#34;output_dir&#34;: results_directory,
            &#34;diagnoses&#34;: diagnoses,
            &#34;modality&#34;: modality,
            &#34;restriction_path&#34;: restriction_path,
            &#34;variables_of_interest&#34;: variables_of_interest,
            &#34;remove_smc&#34;: remove_smc,
            &#34;caps&#34;: caps_directory,
            &#34;missing_mods&#34;: missing_mods,
            &#34;merged_tsv&#34;: merged_tsv,
            &#34;remove_unique_session&#34;: remove_unique_session,
        },
        filename=&#34;labels.json&#34;,
    )

    import os

    from clinica.iotools.utils.data_handling import (
        compute_missing_mods,
        create_merge_file,
    )
    from clinica.utils.inputs import check_bids_folder

    # Create the results directory
    os.makedirs(results_directory, exist_ok=True)

    # Generating the output of `clinica iotools check-missing-modalities``
    missing_mods_directory = os.path.join(results_directory, &#34;missing_mods&#34;)
    if missing_mods is not None:
        missing_mods_directory = missing_mods

    if not os.path.exists(missing_mods_directory):
        check_bids_folder(bids_directory)
        compute_missing_mods(bids_directory, missing_mods_directory, &#34;missing_mods&#34;)

    logger.info(
        f&#34;output of clinica iotools check-missing-modalities: {missing_mods_directory}&#34;
    )

    # Generating the output of `clinica iotools merge-tsv `
    merged_tsv_path = os.path.join(results_directory, &#34;merge.tsv&#34;)
    if merged_tsv is not None:
        merged_tsv_path = merged_tsv
    elif not os.path.exists(merged_tsv_path):
        logger.info(&#34;create merge tsv&#34;)
        check_bids_folder(bids_directory)
        create_merge_file(
            bids_directory,
            os.path.join(results_directory, &#34;merge.tsv&#34;),
            caps_dir=caps_directory,
            pipelines=None,
            ignore_scan_files=None,
            ignore_sessions_files=None,
            volume_atlas_selection=None,
            freesurfer_atlas_selection=None,
            pvc_restriction=None,
            tsv_file=None,
            group_selection=False,
            tracers_selection=False,
        )

    logger.info(f&#34;output of clinica iotools merge-tsv: {merged_tsv_path}&#34;)

    # Reading files
    bids_df = merged_tsv_reader(merged_tsv_path)
    bids_df.set_index([&#34;participant_id&#34;, &#34;session_id&#34;], inplace=True)
    variables_list = []

    if &#34;dx1&#34; in bids_df.columns:
        bids_df.rename(columns={&#34;dx1&#34;: &#34;diagnosis&#34;}, inplace=True)

    try:
        variables_list.append(find_label(bids_df.columns.values, &#34;age&#34;))
        variables_list.append(find_label(bids_df.columns.values, &#34;sex&#34;))
        variables_list.append(find_label(bids_df.columns.values, &#34;diagnosis&#34;))
    except ValueError:
        logger.warning(
            &#34;The age, sex or diagnosis values were not found in the dataset.&#34;
        )

    # Cleaning NaN diagnosis
    bids_df = cleaning_nan_diagnoses(bids_df)

    # Checking the variables of interest
    if variables_of_interest is not None:
        variables_set = set(variables_of_interest) | set(variables_list)
        variables_list = list(variables_set)
        if not set(variables_list).issubset(set(bids_df.columns.values)):
            raise ClinicaDLArgumentError(
                f&#34;The variables asked by the user {variables_of_interest} do not &#34;
                f&#34;exist in the data set.&#34;
            )

    # Loading missing modalities files
    list_files = os.listdir(missing_mods_directory)
    missing_mods_dict = {}

    for file in list_files:
        filename, fileext = path.splitext(file)
        if fileext == &#34;.tsv&#34;:
            session = filename.split(&#34;_&#34;)[-1]
            missing_mods_df = pd.read_csv(
                path.join(missing_mods_directory, file), sep=&#34;\t&#34;
            )
            if len(missing_mods_df) == 0:
                raise ClinicaDLTSVError(
                    f&#34;Given TSV file at {path.join(missing_mods_directory, file)} loads an empty DataFrame.&#34;
                )

            missing_mods_df.set_index(&#34;participant_id&#34;, drop=True, inplace=True)
            missing_mods_dict[session] = missing_mods_df

    # Remove SMC patients
    if remove_smc:
        if &#34;diagnosis_bl&#34; in bids_df.columns.values:  # Retro-compatibility
            bids_df = bids_df[~(bids_df.diagnosis_bl == &#34;SMC&#34;)]
        if &#34;diagnosis_sc&#34; in bids_df.columns.values:
            bids_df = bids_df[~(bids_df.diagnosis_sc == &#34;SMC&#34;)]

    # Adding the field baseline_diagnosis
    bids_copy_df = copy(bids_df)
    bids_copy_df[&#34;baseline_diagnosis&#34;] = pd.Series(
        np.zeros(len(bids_df)), index=bids_df.index
    )
    for subject, subject_df in bids_df.groupby(level=0):
        baseline_diagnosis = subject_df.loc[
            (subject, first_session(subject_df)), &#34;diagnosis&#34;
        ]
        bids_copy_df.loc[subject, &#34;baseline_diagnosis&#34;] = baseline_diagnosis

    bids_df = copy(bids_copy_df)
    variables_list.append(&#34;baseline_diagnosis&#34;)

    bids_df = bids_df[variables_list]
    if remove_unique_session:
        bids_df = remove_unique_session(bids_df)

    variables_list.remove(&#34;baseline_diagnosis&#34;)
    output_df = bids_df[variables_list]
    output_df = infer_or_drop_diagnosis(output_df)
    output_df = diagnosis_removal(output_df, diagnoses)
    output_df = mod_selection(output_df, missing_mods_dict, modality)
    output_df = apply_restriction(output_df, restriction_path)

    output_df.reset_index()
    output_df.sort_values(by=[&#34;participant_id&#34;, &#34;session_id&#34;], inplace=True)
    output_df.to_csv(output_tsv, sep=&#34;\t&#34;)</code></pre>
</details>
</dd>
<dt id="clinicadl.tsvtools.get_labels.get_labels.infer_or_drop_diagnosis"><code class="name flex">
<span>def <span class="ident">infer_or_drop_diagnosis</span></span>(<span>bids_df: pandas.core.frame.DataFrame) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Deduce the diagnosis when missing from previous and following sessions of the subject. If not identical, the session
is dropped. Sessions with no diagnosis are also dropped when there are the last sessions of the follow-up.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bids_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Columns including ['participant_id', 'session_id', 'diagnosis']</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bids_copy_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Cleaned copy of the input bids_df</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def infer_or_drop_diagnosis(bids_df: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Deduce the diagnosis when missing from previous and following sessions of the subject. If not identical, the session
    is dropped. Sessions with no diagnosis are also dropped when there are the last sessions of the follow-up.

    Parameters
    ----------
    bids_df: DataFrame
        Columns including [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;]

    Returns
    -------
    bids_copy_df: DataFrame
        Cleaned copy of the input bids_df
    &#34;&#34;&#34;
    bids_copy_df = copy(bids_df)
    found_diag_interpol = 0
    nb_drop = 0

    for subject, subject_df in bids_df.groupby(level=0):
        session_list = []
        for _, session in subject_df.index.values:
            x = session[5::]
            if not x.isdigit():
                subject_df.drop((subject, session), axis=0, inplace=True)
                bids_copy_df.drop((subject, session), axis=0, inplace=True)
                nb_drop += 1

        session_list = [session for _, session in subject_df.index.values]

        for _, session in subject_df.index.values:
            diagnosis = subject_df.loc[(subject, session), &#34;diagnosis&#34;]
            session_nb = session

            if isinstance(diagnosis, float):
                if session == last_session(session_list):
                    bids_copy_df.drop(index=(_, session), axis=0, inplace=True)
                    nb_drop += 1
                else:
                    prev_session = neighbour_session(session_nb, session_list, -1)
                    prev_diagnosis = bids_df.loc[(subject, prev_session), &#34;diagnosis&#34;]
                    while isinstance(
                        prev_diagnosis, float
                    ) and prev_session != first_session(subject_df):
                        prev_session = neighbour_session(prev_session, session_list, -1)
                        prev_diagnosis = bids_df.loc[
                            (subject, prev_session), &#34;diagnosis&#34;
                        ]
                    post_session = neighbour_session(session_nb, session_list, +1)
                    post_diagnosis = bids_df.loc[(subject, post_session), &#34;diagnosis&#34;]
                    while isinstance(
                        post_diagnosis, float
                    ) and post_session != last_session(session_list):
                        post_session = neighbour_session(post_session, session_list, +1)
                        post_diagnosis = bids_df.loc[
                            (subject, post_session), &#34;diagnosis&#34;
                        ]
                    if prev_diagnosis == post_diagnosis:
                        found_diag_interpol += 1
                        bids_copy_df.loc[
                            (subject, session), &#34;diagnosis&#34;
                        ] = prev_diagnosis
                    else:
                        bids_copy_df.drop((subject, session), inplace=True)
                        nb_drop += 1

    logger.info(f&#34;Inferred diagnosis: {found_diag_interpol}&#34;)
    logger.info(f&#34;Dropped subjects (inferred diagnosis): {nb_drop}&#34;)

    return bids_copy_df</code></pre>
</details>
</dd>
<dt id="clinicadl.tsvtools.get_labels.get_labels.mod_selection"><code class="name flex">
<span>def <span class="ident">mod_selection</span></span>(<span>bids_df: pandas.core.frame.DataFrame, missing_mods_dict: Dict[str, pandas.core.frame.DataFrame], mod: str = 't1w') ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Select only sessions for which the modality is present</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bids_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Columns include ['participant_id', 'session_id', 'diagnosis']</dd>
<dt><strong><code>missing_mods_dict</code></strong> :&ensp;<code>dictionary</code> of <code>str and DataFrame</code></dt>
<dd>DataFrames of missing modalities</dd>
<dt><strong><code>mod</code></strong> :&ensp;<code>str</code></dt>
<dd>the modality used for selection</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>copy_bids_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Cleaned copy of the input bids_df</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mod_selection(
    bids_df: pd.DataFrame, missing_mods_dict: Dict[str, pd.DataFrame], mod: str = &#34;t1w&#34;
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Select only sessions for which the modality is present

    Parameters
    ----------
    bids_df: DataFrame
        Columns include [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;]
    missing_mods_dict: dictionary of str and DataFrame
        DataFrames of missing modalities
    mod: str
        the modality used for selection

    Returns
    -------
    copy_bids_df: DataFrame
        Cleaned copy of the input bids_df
    &#34;&#34;&#34;
    bids_copy_df = copy(bids_df)
    nb_subjects = 0
    if mod is not None:
        for subject, session in bids_df.index.values:
            session_mod = session[:5] + session[6:8]
            try:
                mod_present = missing_mods_dict[session_mod].loc[subject, mod]
                if not mod_present:
                    bids_copy_df.drop((subject, session), inplace=True)
                    nb_subjects += 1
            except KeyError:
                bids_copy_df.drop((subject, session), inplace=True)
                nb_subjects += 1
    logger.info(f&#34;Dropped subjects (mod selection): {nb_subjects}&#34;)
    return bids_copy_df</code></pre>
</details>
</dd>
<dt id="clinicadl.tsvtools.get_labels.get_labels.remove_unique_session"><code class="name flex">
<span>def <span class="ident">remove_unique_session</span></span>(<span>bids_df: pandas.core.frame.DataFrame) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>A method to get the subgroup for each sessions depending on their stability on the time horizon</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bids_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Columns include ['participant_id', 'session_id', 'diagnosis']</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bids_copy_df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Cleaned copy of the input bids_df</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_unique_session(bids_df: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    A method to get the subgroup for each sessions depending on their stability on the time horizon

    Parameters
    ----------
    bids_df: DataFrame
        Columns include [&#39;participant_id&#39;, &#39;session_id&#39;, &#39;diagnosis&#39;]

    Returns
    -------
    bids_copy_df: DataFrame
        Cleaned copy of the input bids_df
    &#34;&#34;&#34;
    bids_copy_df = copy(bids_df)
    nb_unique = 0

    for subject, subject_df in bids_df.groupby(level=0):

        session_list = [session for _, session in subject_df.index.values]
        session_list.sort()
        nb_session = len(session_list)
        if nb_session == 1:
            bids_copy_df.drop((subject, session_list[0]), inplace=True)
            subject_df.drop((subject, session_list[0]), inplace=True)
            nb_unique += 1
    logger.info(f&#34;Dropped subjects (unique session): {nb_unique}&#34;)

    return bids_copy_df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clinicadl.tsvtools.get_labels" href="index.html">clinicadl.tsvtools.get_labels</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="clinicadl.tsvtools.get_labels.get_labels.apply_restriction" href="#clinicadl.tsvtools.get_labels.get_labels.apply_restriction">apply_restriction</a></code></li>
<li><code><a title="clinicadl.tsvtools.get_labels.get_labels.diagnosis_removal" href="#clinicadl.tsvtools.get_labels.get_labels.diagnosis_removal">diagnosis_removal</a></code></li>
<li><code><a title="clinicadl.tsvtools.get_labels.get_labels.get_labels" href="#clinicadl.tsvtools.get_labels.get_labels.get_labels">get_labels</a></code></li>
<li><code><a title="clinicadl.tsvtools.get_labels.get_labels.infer_or_drop_diagnosis" href="#clinicadl.tsvtools.get_labels.get_labels.infer_or_drop_diagnosis">infer_or_drop_diagnosis</a></code></li>
<li><code><a title="clinicadl.tsvtools.get_labels.get_labels.mod_selection" href="#clinicadl.tsvtools.get_labels.get_labels.mod_selection">mod_selection</a></code></li>
<li><code><a title="clinicadl.tsvtools.get_labels.get_labels.remove_unique_session" href="#clinicadl.tsvtools.get_labels.get_labels.remove_unique_session">remove_unique_session</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>